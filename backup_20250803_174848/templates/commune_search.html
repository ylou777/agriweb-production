from flask import Flask, request, render_template, jsonify
import folium
import requests
from folium.plugins import Draw, MeasureControl
from geopy.geocoders import Nominatim
from shapely.geometry import Point, shape
from pyproj import Transformer
import os

app = Flask(__name__)

# === Configuration GeoServer ===
GEOSERVER_URL = "http://localhost:8080/geoserver"
CADASTRE_LAYER = "gpu:cadastre france"
POSTE_LAYER = "gpu:poste_elec_shapefile"          # Postes BT
PLU_LAYER = "gpu:gpu1"
PARCELLE_LAYER = "gpu:PARCELLE2024"
HT_POSTE_LAYER = "gpu:postes-electriques-rte"      # Postes HTA
CAPACITES_RESEAU_LAYER = "gpu:CapacitesDAccueil"
PARKINGS_LAYER = "gpu:parkings_sup500m2"
FRICHES_LAYER = "gpu:friches-standard"
POTENTIEL_SOLAIRE_LAYER = "gpu:POTENTIEL_SOLAIRE_FRICHE_BDD_PSF_LAMB93"
ZAER_LAYER = "gpu:ZAER_ARRETE_SHP_FRA"
PARCELLES_GRAPHIQUES_LAYER = "gpu:PARCELLES_GRAPHIQUES"  # RPG
SIRENE_LAYER = "gpu:GeolocalisationEtablissement_Sirene france"  # Sirene
COMMUNES_LAYER = "gpu:communes-20220101"  # Nouvelles communes

# === Dictionnaire de décodage pour la couche RPG (Annexes A et B) ===
rpg_culture_mapping = {
    # Annexes A – Codes de cultures principales
    "BTH": "Blé tendre d’hiver",
    "BTP": "Blé tendre de printemps",
    "MID": "Maïs doux",
    "MIE": "Maïs ensilage",
    "MIS": "Maïs",
    "ORH": "Orge d'hiver",
    "ORP": "Orge de printemps",
    "AVH": "Avoine d’hiver",
    "AVP": "Avoine de printemps",
    "BDH": "Blé dur d’hiver",
    "BDP": "Blé dur de printemps",
    "BDT": "Blé dur de printemps semé tardivement (après le 31/05)",
    "CAG": "Autre céréale d’un autre genre",
    "CGF": "Autre céréale de genre Fagopyrum",
    "CGH": "Autre céréale de genre Phalaris",
    "CGO": "Autre céréale de genre Sorghum",
    "CGP": "Autre céréale de genre Panicum",
    "CGS": "Autre céréale de genre Setaria",
    "CHA": "Autre céréale d’hiver de genre Avena",
    "CHH": "Autre céréale d’hiver de genre Hordeum",
    "CHS": "Autre céréale d’hiver de genre Secale",
    "CHT": "Autre céréale d’hiver de genre Triticum",
    "CPA": "Autre céréale de printemps de genre Avena",
    "CPH": "Autre céréale de printemps de genre Hordeum",
    "CPS": "Autre céréale de printemps de genre Secale",
    "CPT": "Autre céréale de printemps de genre Triticum",
    "CPZ": "Autre céréale de printemps de genre Zea",
    "EPE": "Épeautre",
    "MCR": "Mélange de céréales",
    "MLT": "Millet",
    "SGH": "Seigle d’hiver",
    "SGP": "Seigle de printemps",
    "SOG": "Sorgho",
    "SRS": "Sarrasin",
    "TTH": "Triticale d’hiver",
    "TTP": "Triticale de printemps",
    "CZH": "Colza d’hiver",
    "CZP": "Colza de printemps",
    "TRN": "Tournesol",
    "ARA": "Arachide",
    "LIH": "Lin non textile d’hiver",
    "LIP": "Lin non textile de printemps",
    "MOL": "Mélange d’oléagineux",
    "NVE": "Navette d’été",
    "NVH": "Navette d’hiver",
    "OAG": "Autre oléagineux d’un autre genre",
    "OEH": "Autre oléagineux d’espèce Helianthus",
    "OEI": "Œillette",
    "OHN": "Autre oléagineux d’hiver d’espèce Brassica napus",
    "OHR": "Autre oléagineux d’hiver d’espèce Brassica rapa",
    "OPN": "Autre oléagineux de printemps d’espèce Brassica napus",
    "OPR": "Autre oléagineux de printemps d’espèce Brassica rapa",
    "SOJ": "Soja",
    # Annexes B – Codes de cultures dérobées
    "FEV": "Fève",
    "FVL": "Féverole semée avant le 31/05",
    "FVT": "Féverole semée tardivement (après le 31/05)",
    "LDH": "Lupin doux d’hiver",
    "LDP": "Lupin doux de printemps semé avant le 31/05",
    "LDT": "Lupin doux de printemps semé tardivement (après le 31/05)",
    "MPC": "Mélange de protéagineux prépondérants semés avant le 31/05 et de céréales",
    "MPP": "Mélange de protéagineux",
    "MPT": "Mélange de protéagineux semés tardivement (après le 31/05)",
    "PAG": "Autre protéagineux d’un autre genre",
    "PHI": "Pois d’hiver",
    "PPR": "Pois de printemps semé avant le 31/05",
    "PPT": "Pois de printemps semé tardivement (après le 31/05)",
    "CHV": "Chanvre",
    "LIF": "Lin fibres",
    "J5M": "Jachère de 5 ans ou moins",
    "J6P": "Jachère de 6 ans ou plus",
    "J6S": "Jachère de 6 ans ou plus déclarée comme Surface d’intérêt écologique",
    "JNO": "Jachère noire",
    "RIZ": "Riz",
    "LEC": "Lentille cultivée (non fourragère)",
    "PCH": "Pois chiche",
    "BVF": "Betterave fourragère",
    "CAF": "Carotte fourragère",
    "CHF": "Chou fourrager",
    "CPL": "Fourrage composé de céréales et/ou de protéagineux (en proportion < 50%) et/ou de légumineuses fourragères (en proportion < 50%)",
    "DTY": "Dactyle de 5 ans ou moins",
    "FAG": "Autre fourrage annuel d’un autre genre",
    "FET": "Fétuque de 5 ans ou moins",
    "FF5": "Féverole fourragère implantée pour la récolte 2015",
    "FF6": "Féverole fourragère implantée pour la récolte 2016",
    "FF7": "Féverole fourragère implantée pour la récolte 2017",
    "FF8": "Féverole fourragère implantée pour la récolte 2018",
    "FFO": "Autre féverole fourragère",
    "FLO": "Fléole de 5 ans ou moins",
    "FSG": "Autre plante fourragère sarclée d’un autre genre",
    "GAI": "Gaillet",
    "GES": "Gesse",
    "GFP": "Autre graminée fourragère pure de 5 ans ou moins",
    "JO5": "Jarosse implantée pour la récolte 2015",
    "JO6": "Jarosse implantée pour la récolte 2016",
    "JO7": "Jarosse implantée pour la récolte 2017",
    "JO8": "Jarosse implantée pour la récolte 2018",
    "JOD": "Jarosse déshydratée",
    "JOS": "Autre jarosse",
    "LEF": "Lentille fourragère",
    "LFH": "Autre lupin fourrager d’hiver",
    "LFP": "Autre lupin fourrager de printemps",
    "LH5": "Lupin fourrager d’hiver implanté pour la récolte 2015",
    "LH6": "Lupin fourrager d’hiver implanté pour la récolte 2016",
    "LH7": "Lupin fourrager d’hiver implanté pour la récolte 2017",
    "LH8": "Lupin fourrager d'hiver implanté pour la récolte 2018",
    "LO7": "Lotier implanté pour la récolte 2017",
    "LO8": "Lotier implanté pour la récolte 2018",
    "LOT": "Lotier",
    "LP5": "Lupin fourrager de printemps implanté pour la récolte 2015",
    "LP6": "Lupin fourrager de printemps implanté pour la récolte 2016",
    "LP7": "Lupin fourrager de printemps implanté pour la récolte 2017",
    "LP8": "Lupin fourrager de printemps implanté pour la récolte 2018",
    "LU5": "Luzerne implantée pour la récolte 2015",
    "LU6": "Luzerne implantée pour la récolte 2016",
    "LU7": "Luzerne implantée pour la récolte 2017",
    "LU8": "Luzerne implantée pour la récolte 2018",
    "LUD": "Luzerne déshydratée",
    "LUZ": "Autre luzerne",
    "MC5": "Mélange de légumineuses fourragères prépondérantes au semis implantées pour la récolte 2015 et de céréales",
    "MC6": "Mélange de légumineuses fourragères prépondérantes au semis implantées pour la récolte 2016 et de céréales",
    "MC7": "Mélange de légumineuses fourragères prépondérantes au semis implantées pour la récolte 2017 et de céréales",
    "MC8": "Mélange de légumineuses fourragères prépondérantes implantées pour la récolte 2018 et de céréales et d’oléagineux",
    "ME5": "Mélilot implanté pour la récolte 2015",
    "ME6": "Mélilot implanté pour la récolte 2016",
    "ME7": "Mélilot implanté pour la récolte 2017",
    "ME8": "Mélilot implanté pour la récolte 2018",
    "MED": "Mélilot déshydraté",
    "MEL": "Autre mélilot",
    "MH5": "Mélange de légumineuses fourragères prépondérantes au semis implantées pour la récolte 2015 et d’herbacées ou de graminées fourragères",
    "MH6": "Mélange de légumineuses fourragères prépondérantes au semis implantées pour la récolte 2016 et d’herbacées ou de graminées fourragères",
    "MH7": "Mélange de légumineuses fourragères prépondérantes au semis implantées pour la récolte 2017 et d’herbacées ou de graminées fourragères",
    "MI7": "Minette implanté pour la récolte 2017",
    "MI8": "Minette implanté pour la récolte 2018",
    "MIN": "Minette",
    "ML5": "Mélange de légumineuses fourragères implantées pour la récolte 2015 (entre elles)",
    "ML6": "Mélange de légumineuses fourragères implantées pour la récolte 2016 (entre elles)",
    "ML7": "Mélange de légumineuses fourragères implantées pour la récolte 2017 (entre elles)",
    "ML8": "Mélange de légumineuses fourragères implantées pour la récolte 2018 (entre elles)",
    "MLC": "Mélange de légumineuses fourragères prépondérantes et de céréales et/ou d’oléagineux",
    "MLD": "Mélange de légumineuses déshydratées (entre elles)",
    "MLF": "Mélange de légumineuses fourragères (entre elles)",
    "MLG": "Mélange de légumineuses prépondérantes au semis et de graminées fourragères de 5 ans ou moins",
    "MOH": "Moha",
    "NVF": "Navet fourrager",
    # Suite du groupe "Légumineuses à grains"
    "PAT": "Pâturin commun de 5 ans ou moins",
    "PFH": "Autre pois fourrager d’hiver",
    "PFP": "Autre pois fourrager de printemps",
    "PH5": "Pois fourrager d’hiver implanté pour la récolte 2015",
    "PH6": "Pois fourrager d’hiver implanté pour la récolte 2016",
    "PH7": "Pois fourrager d’hiver implanté pour la récolte 2017",
    "PH8": "Pois fourrager d’hiver implanté pour la récolte 2018",
    "PP5": "Pois fourrager de printemps implanté pour la récolte 2015",
    "PP6": "Pois fourrager de printemps implanté pour la récolte 2016",
    "PP7": "Pois fourrager de printemps implanté pour la récolte 2017",
    "PP8": "Pois fourrager de printemps implanté pour la récolte 2018",
    "RDF": "Radis fourrager",
    "SA5": "Sainfoin implanté pour la récolte 2015",
    "SA6": "Sainfoin implanté pour la récolte 2016",
    "SA7": "Sainfoin implanté pour la récolte 2017",
    "SA8": "Sainfoin implanté pour la récolte 2018",
    "SAD": "Sainfoin déshydraté",
    "SAI": "Autre sainfoin",
    "SE5": "Serradelle implantée pour la récolte 2015",
    "SE6": "Serradelle implantée pour la récolte 2016",
    "SE7": "Serradelle implantée pour la récolte 2017",
    "SE8": "Serradelle implantée pour la récolte 2018",
    "SED": "Serradelle déshydratée",
    # Groupe "Autre serradelle / Trèfle"
    "SER": "Autre serradelle",
    "TR5": "Trèfle implanté pour la récolte 2015",
    "TR6": "Trèfle implanté pour la récolte 2016",
    "TR7": "Trèfle implanté pour la récolte 2017",
    "TR8": "Trèfle implanté pour la récolte 2018",
    "TRD": "Trèfle déshydraté",
    "TRE": "Autre trèfle",
    "VE5": "Vesce implantée pour la récolte 2015",
    "VE6": "Vesce implantée pour la récolte 2016",
    "VE7": "Vesce implantée pour la récolte 2017",
    "VE8": "Vesce implantée pour la récolte 2018",
    "VED": "Vesce déshydratée",
    "VES": "Autre vesce",
    "XFE": "X-Felium de 5 ans ou moins",
    "BOP": "Bois pâturé",
    # Groupe "Estives et landes / Surface pastorale"
    "SPH": "Surface pastorale - herbe prédominante et ressources fourragères ligneuses présentes",
    "SPL": "Surface pastorale - ressources fourragères ligneuses prédominantes",
    "PPH": "Prairie permanente - herbe prédominante (ressources fourragères ligneuses absentes ou peu présentes)",
    # Groupe "Prairies permanentes / temporaires"
    "PRL": "Prairie en rotation longue (6 ans ou plus)",
    "PTR": "Autre prairie temporaire de 5 ans ou moins",
    "RGA": "Ray-grass de 5 ans ou moins",
    "AGR": "Agrume",
    # Groupe "Vergers"
    "ANA": "Ananas",
    "AVO": "Avocat",
    "BCA": "Banane créole (fruit et légume) - autre",
    # Groupe "Vignes"
    "BCF": "Banane créole (fruit et légume) - fermage",
    "BCI": "Banane créole (fruit et légume) - indivision",
    "BCP": "Banane créole (fruit et légume) - propriété ou faire valoir direct",
    "BCR": "Banane créole (fruit et légume) - réforme foncière",
    "BEA": "Banane export - autre",
    "BEF": "Banane export - fermage",
    "BEI": "Banane export - indivision",
    "BEP": "Banane export - propriété ou faire valoir direct",
    "BER": "Banane export - réforme foncière",
    "CAC": "Café / Cacao",
    "CBT": "Cerise bigarreau pour transformation",
    "PFR": "Petit fruit rouge",
    "PRU": "Prune d’Ente pour transformation",
    "PVT": "Pêche Pavie pour transformation",
    "PWT": "Poire Williams pour transformation",
    "VGD": "Verger (DROM)",
    "VRG": "Verger",
    "RVI": "Restructuration du vignoble",
    # Groupe "Vignes" suite
    "VRC": "Vigne : raisins de cuve",
    "VRN": "Vigne : raisins de cuve non en production",
    "VRT": "Vigne : raisins de table",
    "CAB": "Caroube",
    # Groupe "Fruits à coque"
    "CTG": "Châtaigne",
    "NOS": "Noisette",
    "NOX": "Noix",
    "PIS": "Pistache",
    "OLI": "Oliveraie",
    # Groupe "Oliviers"
    "ANE": "Aneth",
    # Groupe "Autres cultures industrielles"
    "ANG": "Angélique",
    "ANI": "Anis",
    "BAR": "Bardane",
    "BAS": "Basilic",
    # Annexes B – Codes de cultures dérobées
    "DBM": "Brôme",
    "DBR": "Bourrache",
    "DCF": "Chou fourrager",
    "DCM": "Cameline",
    "DCR": "Cresson alénois",
    "DCZ": "Colza",
    "DDC": "Dactyle",
    "DFL": "Fléole",
    "DFN": "Fenugrec",
    "DFT": "Fétuque",
    "DFV": "Féverole",
    "DGS": "Gesse cultivée",
    "DLN": "Lin",
    "DLL": "Lentille",
    "DLP": "Lupin (blanc, bleu, jaune)",
    "DLT": "Lotier corniculé",
    "DLZ": "Luzerne cultivée",
    "DMD": "Moutarde",
    "DMH": "Moha",
    "DML": "Millet jaune, perlé",
    "DMN": "Minette",
    "DMT": "Mélilot",
    "DNG": "Nyger",
    "DNT": "Navette",
    "DNV": "Navet",
    "DPC": "Pois chiche",
    "DPH": "Phacélie",
    "DPS": "Pois",
    "DPT": "Pâturin commun",
    "DRD": "Radis (fourrager, chinois)",
    "DRG": "Ray-grass",
    "DRQ": "Roquette",
    "DSD": "Serradelle",
    "DSF": "Sorgho fourrager"
}

# === Fonctions utilitaires ===

def geocode_address(address):
    geolocator = Nominatim(user_agent="geoapp", timeout=10)
    location = geolocator.geocode(address)
    if location:
        return location.latitude, location.longitude
    return None

def fetch_wfs_data(layer, bbox, srsname="EPSG:4326"):
    wfs_url = f"{GEOSERVER_URL}/wfs"
    params = {
        "service": "WFS",
        "version": "1.0.0",
        "request": "GetFeature",
        "typeName": layer,
        "outputFormat": "application/json",
        "srsname": srsname,
        "bbox": bbox
    }
    response = requests.get(wfs_url, params=params)
    if response.status_code == 200:
        return response.json().get("features", [])
    print(f"Erreur WFS ({layer}): {response.status_code} - {response.text}")
    return []

def get_parcelle_info(lat, lon):
    bbox = f"{lon-0.001},{lat-0.001},{lon+0.001},{lat+0.001},EPSG:4326"
    features = fetch_wfs_data(CADASTRE_LAYER, bbox)
    point = Point(lon, lat)
    for feature in features:
        geom = shape(feature["geometry"])
        if geom.contains(point):
            parcelle_info = feature["properties"]
            parcelle_info["geometry"] = feature["geometry"]
            return parcelle_info
    return None

def get_all_parcelles(lat, lon, radius=0.03):
    transformer = Transformer.from_crs("EPSG:4326", "EPSG:2154", always_xy=True)
    x, y = transformer.transform(lon, lat)
    bbox = f"{x - radius*111000},{y - radius*111000},{x + radius*111000},{y + radius*111000},EPSG:2154"
    url = f"{GEOSERVER_URL}/wfs"
    params = {
        "service": "WFS",
        "version": "1.0.0",
        "request": "GetFeature",
        "typeName": PARCELLE_LAYER,
        "outputFormat": "application/json",
        "bbox": bbox
    }
    response = requests.get(url, params=params)
    if response.status_code == 200:
        return response.json()
    print(f"Erreur parcelles: {response.status_code}, {response.text}")
    return {"features": []}

def add_wms_layer(map_obj, layer_name, display_name, opacity=1.0):
    folium.raster_layers.WmsTileLayer(
        url=f"{GEOSERVER_URL}/wms",
        layers=layer_name,
        fmt="image/png",
        transparent=True,
        opacity=opacity,
        name=display_name,
        overlay=True,
        control=True
    ).add_to(map_obj)

def get_nearest_postes(lat, lon, radius_deg=0.1):
    bbox = f"{lon - radius_deg},{lat - radius_deg},{lon + radius_deg},{lat + radius_deg},EPSG:4326"
    features = fetch_wfs_data(POSTE_LAYER, bbox)
    postes = []
    point = Point(lon, lat)
    for feature in features:
        geom = shape(feature["geometry"])
        distance = geom.distance(point) * 111000
        postes.append({
            "properties": feature["properties"],
            "distance": round(distance, 2),
            "geometry": geom
        })
    return sorted(postes, key=lambda x: x["distance"])[:3]

def get_nearest_ht_postes(lat, lon, radius_deg=0.1):
    bbox = f"{lon - radius_deg},{lat - radius_deg},{lon + radius_deg},{lat + radius_deg},EPSG:4326"
    features = fetch_wfs_data(HT_POSTE_LAYER, bbox)
    postes = []
    point = Point(lon, lat)
    for feature in features:
        geom = shape(feature["geometry"])
        distance = geom.distance(point) * 111000
        postes.append({
            "properties": feature["properties"],
            "distance": round(distance, 2),
            "geometry": geom
        })
    return sorted(postes, key=lambda x: x["distance"])[:3]

def get_nearest_capacites_reseau(lat, lon, count=3, radius_deg=0.1):
    bbox = f"{lon - radius_deg},{lat - radius_deg},{lon + radius_deg},{lat + radius_deg},EPSG:4326"
    features = fetch_wfs_data(CAPACITES_RESEAU_LAYER, bbox)
    capacites = []
    point = Point(lon, lat)
    for feature in features:
        geom = shape(feature["geometry"])
        distance = geom.distance(point) * 111000
        capacites.append({
            "properties": feature["properties"],
            "distance": round(distance, 2),
            "geometry": geom
        })
    return sorted(capacites, key=lambda x: x["distance"])[:count]

def get_plu_info(lat, lon, radius=0.03):
    bbox = f"{lon - radius},{lat - radius},{lon + radius},{lat + radius},EPSG:4326"
    features = fetch_wfs_data(PLU_LAYER, bbox)
    plu_info = []
    for feature in features:
        props = feature["properties"]
        plu_info.append({
            "insee": props.get("insee"),
            "typeref": props.get("typeref"),
            "archive_url": props.get("archiveUrl"),
            "files": props.get("files", "").split(", ")
        })
    return plu_info

def get_sirene_info(lat, lon, radius):
    bbox = f"{lon - radius},{lat - radius},{lon + radius},{lat + radius},EPSG:4326"
    return fetch_wfs_data(SIRENE_LAYER, bbox)

def get_rpg_info(lat, lon, radius=0.0027):
    bbox = f"{lon - radius},{lat - radius},{lon + radius},{lat + radius},EPSG:4326"
    return fetch_wfs_data(PARCELLES_GRAPHIQUES_LAYER, bbox)

def get_parkings_info(lat, lon, radius=0.03):
    bbox = f"{lon - radius},{lat - radius},{lon + radius},{lat + radius},EPSG:4326"
    return fetch_wfs_data(PARKINGS_LAYER, bbox)

def get_friches_info(lat, lon, radius=0.03):
    bbox = f"{lon - radius},{lat - radius},{lon + radius},{lat + radius},EPSG:4326"
    return fetch_wfs_data(FRICHES_LAYER, bbox)

def get_potentiel_solaire_info(lat, lon, radius=1.0):
    bbox = f"{lon - radius},{lat - radius},{lon + radius},{lat + radius},EPSG:4326"
    return fetch_wfs_data(POTENTIEL_SOLAIRE_LAYER, bbox)

def get_zaer_info(lat, lon, radius=0.03):
    bbox = f"{lon - radius},{lat - radius},{lon + radius},{lat + radius},EPSG:4326"
    return fetch_wfs_data(ZAER_LAYER, bbox)

def get_commune_geometry(commune_name):
    wfs_url = f"{GEOSERVER_URL}/wfs"
    params = {
        "service": "WFS",
        "version": "1.0.0",
        "request": "GetFeature",
        "typeName": COMMUNES_LAYER,
        "outputFormat": "application/json",
        "CQL_FILTER": f"NOM='{commune_name}'"
    }
    response = requests.get(wfs_url, params=params)
    if response.status_code == 200:
        features = response.json().get("features", [])
        if features:
            return features[0]
    return None

def get_features_in_bbox(layer, bbox, srsname="EPSG:4326"):
    bbox_str = f"{bbox[0]},{bbox[1]},{bbox[2]},{bbox[3]},EPSG:4326"
    return fetch_wfs_data(layer, bbox_str, srsname)

def decode_rpg_feature(feature):
    props = feature.get("properties", {})
    code = props.get("CODE_CULTU", "").strip()
    props["Culture"] = rpg_culture_mapping.get(code, code or "Non défini")
    return feature

def build_map(lat, lon, address, parcelle_props, parcelles_data, postes_data, ht_postes_data,
              plu_info, parkings_data, friches_data, potentiel_solaire_data, zaer_data,
              rpg_data, sirene_data, search_radius, ht_radius_deg):
    map_obj = folium.Map(location=[lat, lon], zoom_start=17)
    folium.TileLayer('OpenStreetMap', name="Carte OSM").add_to(map_obj)
    Draw(export=True).add_to(map_obj)
    MeasureControl(position='topright', primary_length_unit='meters',
                   primary_area_unit='sqmeters', secondary_area_unit='hectares').add_to(map_obj)
    address_street_view = f"https://www.google.com/maps/@?api=1&map_action=pano&viewpoint={lat},{lon}&heading=0&pitch=0&fov=80"
    geoportail_url = f"https://www.geoportail-urbanisme.gouv.fr/map/#tile=1&lon={lon}&lat={lat}&zoom=19&mlon={lon}&mlat={lat}"
    folium.Marker([lat, lon],
                  popup=f"<b>Adresse :</b> {address}<br><a href='{address_street_view}' target='_blank'>Voir Street View</a><br><a href='{geoportail_url}' target='_blank'>Voir sur Geoportail</a>",
                  icon=folium.Icon(color="blue")).add_to(map_obj)
    # Cadastre
    cadastre_group = folium.FeatureGroup(name="Cadastre", show=True)
    if parcelle_props:
        tooltip_text = "<br>".join([f"{k}: {v}" for k, v in parcelle_props.items() if k != "geometry"])
        folium.GeoJson(parcelle_props.get("geometry", {}),
                       style_function=lambda x: {"color": "blue", "weight": 2, "opacity": 0.8},
                       tooltip=tooltip_text).add_to(cadastre_group)
    if parcelles_data.get("features"):
        for parcelle in parcelles_data["features"]:
            geom = parcelle.get("geometry")
            props = parcelle.get("properties", {})
            tooltip_text = "<br>".join([f"{k}: {v}" for k, v in props.items()])
            if geom:
                folium.GeoJson(geom,
                               style_function=lambda x: {"color": "purple", "weight": 2, "opacity": 0.5},
                               tooltip=tooltip_text).add_to(cadastre_group)
    map_obj.add_child(cadastre_group)
    # Postes BT
    for poste in postes_data:
        coords = poste["geometry"].centroid.coords[0]
        poste_info = poste["properties"]
        pst_link = f"https://www.google.com/maps/@?api=1&map_action=pano&viewpoint={coords[1]},{coords[0]}&heading=0&pitch=0&fov=80"
        folium.Marker([coords[1], coords[0]],
                      popup=f"<b>Poste BT</b><br>Distance: {poste['distance']} m<br>{'<br>'.join([f'{k}: {v}' for k, v in poste_info.items()])}<br><a href='{pst_link}' target='_blank'>Voir Street View</a>",
                      icon=folium.Icon(color="green")).add_to(map_obj)
    # Postes HTA
    for poste in ht_postes_data:
        coords = poste["geometry"].centroid.coords[0]
        poste_info = poste["properties"]
        folium.Marker([coords[1], coords[0]],
                      popup=f"<b>Poste HTA</b><br>Distance: {poste['distance']} m<br>{'<br>'.join([f'{k}: {v}' for k, v in poste_info.items()])}",
                      icon=folium.Icon(color="orange", icon="bolt")).add_to(map_obj)
    add_wms_layer(map_obj, CAPACITES_RESEAU_LAYER, "Capacités d'accueil")
    add_wms_layer(map_obj, PARCELLE_LAYER, "Parcelles WMS")
    add_wms_layer(map_obj, POTENTIEL_SOLAIRE_LAYER, "Potentiel Solaire", opacity=1.0)
    add_wms_layer(map_obj, ZAER_LAYER, "ZAER", opacity=1.0)
    folium.TileLayer(tiles="https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
                     attr="Esri", name="Satellite", overlay=False, control=True).add_to(map_obj)
    if parkings_data:
        parkings_group = folium.FeatureGroup(name="Parkings", show=True)
        for feature in parkings_data:
            geom = feature.get("geometry")
            props = feature.get("properties", {})
            if geom:
                shp = shape(geom)
                centroid = shp.centroid.coords[0]
                gml = f"https://www.google.com/maps/search/?api=1&query={centroid[1]},{centroid[0]}"
                content = f"<b>Parking Sup 500m²</b><br>Coordonnées: {centroid[1]:.6f}, {centroid[0]:.6f}<br><a href='{gml}' target='_blank'>Voir sur Google Maps</a><br>"
                content += "<br>".join([f"{k}: {v}" for k, v in props.items()])
                folium.GeoJson(geom,
                               style_function=lambda x: {"color": "darkgreen", "weight": 2, "opacity": 0.7},
                               tooltip=content).add_to(parkings_group)
                folium.Marker([centroid[1], centroid[0]],
                              popup=content,
                              icon=folium.Icon(color="red", icon="info-sign")).add_to(parkings_group)
        map_obj.add_child(parkings_group)
    if friches_data:
        friches_group = folium.FeatureGroup(name="Friches", show=True)
        for feature in friches_data:
            geom = feature.get("geometry")
            props = feature.get("properties", {})
            if geom:
                shp = shape(geom)
                centroid = shp.centroid.coords[0]
                content = f"<b>Friches Standard</b><br>Coordonnées: {centroid[1]:.6f}, {centroid[0]:.6f}<br>"
                content += "<br>".join([f"{k}: {v}" for k, v in props.items()])
                folium.GeoJson(geom,
                               style_function=lambda x: {"color": "brown", "weight": 2, "opacity": 0.7},
                               tooltip=content).add_to(friches_group)
        map_obj.add_child(friches_group)
    potentiel_group = folium.FeatureGroup(name="Potentiel Solaire", show=True)
    if potentiel_solaire_data:
        for feature in potentiel_solaire_data:
            geom = feature.get("geometry")
            props = feature.get("properties", {})
            if geom:
                tip = "<br>".join([f"{k}: {v}" for k,v in props.items()])
                folium.GeoJson(geom,
                               style_function=lambda x: {"color": "yellow", "weight": 2, "opacity": 0.7},
                               tooltip=tip).add_to(potentiel_group)
        map_obj.add_child(potentiel_group)
    zaer_group = folium.FeatureGroup(name="ZAER", show=True)
    if zaer_data:
        for feature in zaer_data:
            geom = feature.get("geometry")
            props = feature.get("properties", {})
            if geom:
                tip = "<br>".join([f"{k}: {v}" for k,v in props.items()])
                folium.GeoJson(geom,
                               style_function=lambda x: {"color": "cyan", "weight": 2, "opacity": 0.7},
                               tooltip=tip).add_to(zaer_group)
        map_obj.add_child(zaer_group)
    # Couche PLU (affichage complet)
    plu_bbox = f"{lon-0.0027},{lat-0.0027},{lon+0.0027},{lat+0.0027},EPSG:4326"
    plu_features = fetch_wfs_data(PLU_LAYER, plu_bbox)
    plu_group = folium.FeatureGroup(name="PLU", show=True)
    if plu_features:
        fc = {"type": "FeatureCollection", "features": []}
        for feature in plu_features:
            geom = feature.get("the_geom") or feature.get("geom") or feature.get("geometry")
            if geom:
                feature["geometry"] = geom
                fc["features"].append(feature)
        if fc["features"]:
            tip = folium.GeoJsonTooltip(fields=["insee", "typeref", "archiveUrl", "files"],
                                        aliases=["INSEE", "Type", "Archive URL", "Files"],
                                        localize=True)
            folium.GeoJson(fc,
                           style_function=lambda f: {"color": "red", "weight": 2, "opacity": 0.7},
                           tooltip=tip).add_to(plu_group)
    map_obj.add_child(plu_group)
    rpg_serializable = []
    if rpg_data:
        for feature in rpg_data:
            decoded = decode_rpg_feature(feature)
            rpg_serializable.append(decoded["properties"])
    if rpg_serializable:
        rpg_group = folium.FeatureGroup(name="RPG", show=True)
        for props in rpg_serializable:
            tip = f"Culture: {props.get('Culture', 'Non défini')}, ID Parcelle: {props.get('ID_PARCEL', 'Non défini')}, Surface: {props.get('SURF_PARC', 'Non défini')} ha"
            folium.Marker([lat, lon],
                          popup=f"<b>RPG</b><br>{tip}",
                          icon=folium.Icon(color="darkblue", icon="info-sign")).add_to(rpg_group)
        map_obj.add_child(rpg_group)
    if sirene_data:
        for feature in sirene_data:
            geom = feature.get("geometry")
            if geom:
                shp = shape(geom)
                centroid = shp.centroid.coords[0]
                props = feature.get("properties", {})
                siret = props.get("siret", "inconnu")
                link = f"<br><a href='https://annuaire-entreprises.data.gouv.fr/etablissement/{siret}?redirected=1' target='_blank'>Voir Fiche Entreprise</a>"
                tip = "<br>".join([f"{k}: {v}" for k, v in props.items()])
                folium.Marker([centroid[1], centroid[0]],
                              popup=f"<b>SIRENE</b><br>{tip}{link}",
                              icon=folium.Icon(color="darkred", icon="info-sign")).add_to(map_obj)
    capacites_reseau = get_nearest_capacites_reseau(lat, lon, count=3, radius_deg=ht_radius_deg)
    hta_group = folium.FeatureGroup(name="Postes HTA (Capacités d'accueil)", show=True)
    # Exemple d'un mapping pour HTA (à ajuster selon vos colonnes)
    hta_mapping = {
        "Code": "Code",
        "Taux d'affectation des capacités réservées": "Taux d'aff",
        "X": "X",
        "Y": "Y",
        "Puissance EnR déjà raccordée": "Puissanc_2",
        "Puissance des projets EnR en développement": "Puissanc_1",
        "Capacité réservée aux EnR au titre du S3REnR": "Puissanc_6",
        "Attention: la valeur de la capacité réservée a été modifiée sur ce poste": "Attention:",
        "Quote-Part unitaire actualisée": "Quote-Part",
        "dont la convention de raccordement est signée": "dont la co"
    }
    if capacites_reseau:
        for item in capacites_reseau:
            props = item["properties"]
            ht_item = {}
            for dk, sk in hta_mapping.items():
                ht_item[dk] = props.get(sk, "Non défini")
            ht_item["distance"] = item["distance"]
            lines = []
            for key in hta_mapping:
                lines.append(f"<strong>{key}:</strong> {ht_item[key]}")
            lines.append(f"<strong>Distance:</strong> {ht_item['distance']} m")
            content = "<br>".join(lines)
            centroid = item["geometry"].centroid.coords[0]
            folium.Marker([centroid[1], centroid[0]],
                          popup=f"<b>Poste HTA</b><br>{content}",
                          icon=folium.Icon(color="purple", icon="flash")).add_to(hta_group)
    map_obj.add_child(hta_group)
    folium.LayerControl().add_to(map_obj)
    map_obj.add_child(folium.ClickForMarker(popup=None))
    click_js = """
    <script>
    // Wait for the map to be initialized
    document.addEventListener("DOMContentLoaded", function() {
        if (window.map) {
            window.map.on('click', function(e) {
                var coord = e.latlng;
                alert("Clicked coordinates: " + coord.lat + ", " + coord.lng);
            });
        }
    });
    </script>
    """
    map_obj.get_root().html.add_child(folium.Element(click_js))
    return map_obj

# === Routes ===

# Route principale: Recherche par adresse
@app.route("/", methods=["GET", "POST"])
def index():
    lat, lon = 46.603354, 1.888334
    address = None
    parcelle_props = {}
    postes_data = []
    ht_postes_data = []
    plu_info = []
    parkings_data = []
    friches_data = []
    potentiel_solaire_data = []
    zaer_data = []
    rpg_data = []
    sirene_data = []
    search_radius = 0.03
    coords = None
    ht_radius_km = 1.0
    bt_radius_km = 1.0
    sirene_radius_km = 0.05

    if request.method == "POST":
        address = request.form.get("address")
        sr = request.form.get("sirene_radius")
        if sr:
            try:
                sirene_radius_km = float(sr)
            except ValueError:
                sirene_radius_km = 0.05
        ht_input = request.form.get("ht_radius")
        bt_input = request.form.get("bt_radius")
        if ht_input:
            try:
                ht_radius_km = float(ht_input)
            except ValueError:
                ht_radius_km = 1.0
        if bt_input:
            try:
                bt_radius_km = float(bt_input)
            except ValueError:
                bt_radius_km = 1.0
        coords = geocode_address(address)
        if coords:
            lat, lon = coords
            parcelle = get_parcelle_info(lat, lon)
            if not parcelle:
                all_parcelles = get_all_parcelles(lat, lon, radius=search_radius)
                if all_parcelles.get("features"):
                    parcelle = all_parcelles["features"][0]["properties"]
            if parcelle:
                parcelle_props = parcelle
            bt_deg = bt_radius_km / 111
            ht_deg = ht_radius_km / 111
            postes_data = get_nearest_postes(lat, lon, radius_deg=bt_deg)
            ht_postes_data = get_nearest_ht_postes(lat, lon, radius_deg=ht_deg)
            plu_info = get_plu_info(lat, lon, radius=search_radius)
            parkings_data = get_parkings_info(lat, lon, radius=search_radius)
            friches_data = get_friches_info(lat, lon, radius=search_radius)
            potentiel_solaire_data = get_potentiel_solaire_info(lat, lon)
            zaer_data = get_zaer_info(lat, lon, radius=search_radius)
            rpg_data = get_rpg_info(lat, lon, radius=0.0027)
            sirene_deg = sirene_radius_km / 111
            sirene_data = get_sirene_info(lat, lon, radius=sirene_deg)
    # Toujours recharger pour info
    rpg_data = get_rpg_info(lat, lon, radius=0.0027)
    sirene_data = get_sirene_info(lat, lon, radius=0.00045)
    capacites_reseau = get_nearest_capacites_reseau(lat, lon, count=3, radius_deg=ht_radius_km/111)
    hta_serializable = []
    hta_mapping = {
        "Code": "Code",
        "Taux d'affectation des capacités réservées": "Taux d'aff",
        "X": "X",
        "Y": "Y",
        "Puissance EnR déjà raccordée": "Puissanc_2",
        "Puissance des projets EnR en développement": "Puissanc_1",
        "Capacité réservée aux EnR au titre du S3REnR": "Puissanc_6",
        "Attention: la valeur de la capacité réservée a été modifiée sur ce poste": "Attention:",
        "Quote-Part unitaire actualisée": "Quote-Part",
        "dont la convention de raccordement est signée": "dont la co"
    }
    for item in capacites_reseau:
        props = item["properties"]
        ht_item = {}
        for dk, sk in hta_mapping.items():
            ht_item[dk] = props.get(sk, "Non défini")
        ht_item["distance"] = item["distance"]
        hta_serializable.append(ht_item)
    bt_serializable = []
    for item in postes_data:
        bt_serializable.append({
            "distance": item["distance"],
            "properties": item["properties"]
        })
    rpg_serializable = []
    for feature in rpg_data:
        decoded = decode_rpg_feature(feature)
        rpg_serializable.append(decoded["properties"])
    info_response = {
        "lat": lat,
        "lon": lon,
        "address": address,
        "parcelle": parcelle_props,
        "plu": plu_info,
        "sirene_radius_km": sirene_radius_km,
        "hta": hta_serializable,
        "bt": bt_serializable,
        "rpg": rpg_serializable,
        "ht_radius_km": ht_radius_km,
        "bt_radius_km": bt_radius_km
    }
    if request.method == "POST" and coords:
        map_obj = build_map(lat, lon, address, parcelle_props, get_all_parcelles(lat, lon, radius=search_radius),
                            postes_data, ht_postes_data, plu_info,
                            parkings_data, friches_data, potentiel_solaire_data,
                            zaer_data, rpg_data, sirene_data, search_radius, ht_deg)
        map_obj.save(os.path.join(app.root_path, "templates", "map.html"))
    else:
        map_obj = folium.Map(location=[lat, lon], zoom_start=6)
        map_obj.save(os.path.join(app.root_path, "templates", "map.html"))
    return render_template("index.html",
                           address=address,
                           parcelle=parcelle_props,
                           postes=postes_data,
                           ht_postes=ht_postes_data,
                           plu=plu_info,
                           parcelles_data={},
                           lat=lat,
                           lon=lon,
                           rpg_data=rpg_data,
                           sirene_data=sirene_data,
                           info=info_response)

# Recherche par commune
@app.route("/commune_search", methods=["GET", "POST"])
def commune_search():
    if request.method == "POST":
        commune = request.form.get("commune")
        culture = request.form.get("culture")  # Code de culture à filtrer ou "all"
        ht_radius_km = float(request.form.get("ht_radius", 1.0))
        bt_radius_km = float(request.form.get("bt_radius", 1.0))
        commune_feature = get_commune_geometry(commune)
        if not commune_feature:
            return jsonify({"error": "Commune non trouvée."})
        geom = shape(commune_feature["geometry"])
        bbox = geom.bounds
        centroid = geom.centroid
        lat_center, lon_center = centroid.y, centroid.x
        # Récupérer les parcelles RPG dans le bbox
        rpg_features = get_features_in_bbox(PARCELLES_GRAPHIQUES_LAYER, bbox)
        filtered_rpg = []
        for feature in rpg_features:
            props = feature.get("properties", {})
            code = props.get("CODE_CULTU", "").strip()
            if culture and culture.lower() != "all":
                if code != culture:
                    continue
            filtered_rpg.append(feature)
        bt_deg = bt_radius_km / 111
        ht_deg = ht_radius_km / 111
        posts_bt = get_nearest_postes(lat_center, lon_center, radius_deg=bt_deg)
        posts_hta = get_nearest_ht_postes(lat_center, lon_center, radius_deg=ht_deg)
        posts_bt = [p for p in posts_bt if geom.contains(p["geometry"])]
        posts_hta = [p for p in posts_hta if geom.contains(p["geometry"])]
        map_obj = folium.Map(location=[lat_center, lon_center], zoom_start=14)
        commune_group = folium.FeatureGroup(name="Commune", show=True)
        folium.GeoJson(commune_feature["geometry"],
                       style_function=lambda x: {"color": "black", "weight": 2, "opacity": 0.8},
                       tooltip=f"Commune: {commune}").add_to(commune_group)
        map_obj.add_child(commune_group)
        rpg_group = folium.FeatureGroup(name="Parcelles RPG", show=True)
        for feature in filtered_rpg:
            tip = "<br>".join([f"{k}: {v}" for k, v in feature.get("properties", {}).items()])
            folium.GeoJson(feature["geometry"],
                           style_function=lambda x: {"color": "purple", "weight": 2, "opacity": 0.5},
                           tooltip=tip).add_to(rpg_group)
        map_obj.add_child(rpg_group)
        bt_group = folium.FeatureGroup(name="Postes BT", show=True)
        for p in posts_bt:
            coords = p["geometry"].centroid.coords[0]
            tip = "<br>".join([f"{k}: {v}" for k, v in p["properties"].items()])
            folium.Marker([coords[1], coords[0]],
                          popup=f"<b>Poste BT</b><br>Distance: {p['distance']} m<br>{tip}",
                          icon=folium.Icon(color="green")).add_to(bt_group)
        map_obj.add_child(bt_group)
        hta_group = folium.FeatureGroup(name="Postes HTA", show=True)
        for p in posts_hta:
            coords = p["geometry"].centroid.coords[0]
            tip = "<br>".join([f"{k}: {v}" for k, v in p["properties"].items()])
            folium.Marker([coords[1], coords[0]],
                          popup=f"<b>Poste HTA</b><br>Distance: {p['distance']} m<br>{tip}",
                          icon=folium.Icon(color="orange", icon="bolt")).add_to(hta_group)
        map_obj.add_child(hta_group)
        folium.LayerControl().add_to(map_obj)
        map_obj.save(os.path.join(app.root_path, "templates", "map.html"))
        info_response = {
            "commune": commune,
            "culture": culture,
            "ht_radius_km": ht_radius_km,
            "bt_radius_km": bt_radius_km,
            "rpg_count": len(filtered_rpg),
            "posts_bt_count": len(posts_bt),
            "posts_hta_count": len(posts_hta)
        }
        return render_template("commune_index.html", info=info_response)
    else:
        return render_template("commune_search.html")

@app.route("/map.html")
def serve_map():
    return render_template("map.html")

# Pour éviter doublon d'endpoint "index", nous utilisons uniquement "/" pour la recherche par adresse.
@app.route("/search_by_address", methods=["GET", "POST"])
def search_by_address_route():
    lat, lon = 46.603354, 1.888334
    address = None
    parcelle_props = {}
    postes_data = []
    ht_postes_data = []
    plu_info = []
    parkings_data = []
    friches_data = []
    potentiel_solaire_data = []
    zaer_data = []
    rpg_data = []
    sirene_data = []
    search_radius = 0.03
    coords = None
    ht_radius_km = 1.0
    bt_radius_km = 1.0
    sirene_radius_km = 0.05

    if request.method == "POST":
        address = request.form.get("address")
        sr = request.form.get("sirene_radius")
        if sr:
            try:
                sirene_radius_km = float(sr)
            except ValueError:
                sirene_radius_km = 0.05
        ht_input = request.form.get("ht_radius")
        bt_input = request.form.get("bt_radius")
        if ht_input:
            try:
                ht_radius_km = float(ht_input)
            except ValueError:
                ht_radius_km = 1.0
        if bt_input:
            try:
                bt_radius_km = float(bt_input)
            except ValueError:
                bt_radius_km = 1.0
        coords = geocode_address(address)
        if coords:
            lat, lon = coords
            parcelle = get_parcelle_info(lat, lon)
            if not parcelle:
                all_parcelles = get_all_parcelles(lat, lon, radius=search_radius)
                if all_parcelles.get("features"):
                    parcelle = all_parcelles["features"][0]["properties"]
            if parcelle:
                parcelle_props = parcelle
            bt_deg = bt_radius_km / 111
            ht_deg = ht_radius_km / 111
            postes_data = get_nearest_postes(lat, lon, radius_deg=bt_deg)
            ht_postes_data = get_nearest_ht_postes(lat, lon, radius_deg=ht_deg)
            plu_info = get_plu_info(lat, lon, radius=search_radius)
            parkings_data = get_parkings_info(lat, lon, radius=search_radius)
            friches_data = get_friches_info(lat, lon, radius=search_radius)
            potentiel_solaire_data = get_potentiel_solaire_info(lat, lon)
            zaer_data = get_zaer_info(lat, lon, radius=search_radius)
            rpg_data = get_rpg_info(lat, lon, radius=0.0027)
            sirene_deg = sirene_radius_km / 111
            sirene_data = get_sirene_info(lat, lon, radius=sirene_deg)
    rpg_data = get_rpg_info(lat, lon, radius=0.0027)
    sirene_data = get_sirene_info(lat, lon, radius=0.00045)
    capacites_reseau = get_nearest_capacites_reseau(lat, lon, count=3, radius_deg=ht_radius_km/111)
    hta_serializable = []
    hta_mapping = {
        "Code": "Code",
        "Taux d'affectation des capacités réservées": "Taux d'aff",
        "X": "X",
        "Y": "Y",
        "Puissance EnR déjà raccordée": "Puissanc_2",
        "Puissance des projets EnR en développement": "Puissanc_1",
        "Capacité réservée aux EnR au titre du S3REnR": "Puissanc_6",
        "Attention: la valeur de la capacité réservée a été modifiée sur ce poste": "Attention:",
        "Quote-Part unitaire actualisée": "Quote-Part",
        "dont la convention de raccordement est signée": "dont la co"
    }
    for item in capacites_reseau:
        props = item["properties"]
        ht_item = {}
        for dk, sk in hta_mapping.items():
            ht_item[dk] = props.get(sk, "Non défini")
        ht_item["distance"] = item["distance"]
        hta_serializable.append(ht_item)
    bt_serializable = []
    for item in postes_data:
        bt_serializable.append({
            "distance": item["distance"],
            "properties": item["properties"]
        })
    rpg_serializable = []
    for feature in rpg_data:
        decoded = decode_rpg_feature(feature)
        rpg_serializable.append(decoded["properties"])
    info_response = {
        "lat": lat,
        "lon": lon,
        "address": address,
        "parcelle": parcelle_props,
        "plu": plu_info,
        "sirene_radius_km": sirene_radius_km,
        "hta": hta_serializable,
        "bt": bt_serializable,
        "rpg": rpg_serializable,
        "ht_radius_km": ht_radius_km,
        "bt_radius_km": bt_radius_km
    }
    if request.method == "POST" and coords:
        map_obj = build_map(lat, lon, address, parcelle_props, get_all_parcelles(lat, lon, radius=search_radius),
                            postes_data, ht_postes_data, plu_info,
                            parkings_data, friches_data, potentiel_solaire_data,
                            zaer_data, rpg_data, sirene_data, search_radius, ht_deg)
        map_obj.save(os.path.join(app.root_path, "templates", "map.html"))
    else:
        map_obj = folium.Map(location=[lat, lon], zoom_start=6)
        map_obj.save(os.path.join(app.root_path, "templates", "map.html"))
    return render_template("index.html",
                           address=address,
                           parcelle=parcelle_props,
                           postes=postes_data,
                           ht_postes=ht_postes_data,
                           plu=plu_info,
                           parcelles_data={},
                           lat=lat,
                           lon=lon,
                           rpg_data=rpg_data,
                           sirene_data=sirene_data,
                           info=info_response)

@app.route("/map.html")
def serve_map():
    return render_template("map.html")

# === Route commune_search pour recherche par commune ===
@app.route("/commune_search", methods=["GET", "POST"])
def commune_search():
    if request.method == "POST":
        commune = request.form.get("commune")
        culture = request.form.get("culture")  # Code de culture à filtrer ou "all"
        ht_radius_km = float(request.form.get("ht_radius", 1.0))
        bt_radius_km = float(request.form.get("bt_radius", 1.0))
        commune_feature = get_commune_geometry(commune)
        if not commune_feature:
            return jsonify({"error": "Commune non trouvée."})
        geom = shape(commune_feature["geometry"])
        bbox = geom.bounds
        centroid = geom.centroid
        lat_center, lon_center = centroid.y, centroid.x
        rpg_features = get_features_in_bbox(PARCELLES_GRAPHIQUES_LAYER, bbox)
        filtered_rpg = []
        for feature in rpg_features:
            props = feature.get("properties", {})
            code = props.get("CODE_CULTU", "").strip()
            if culture and culture.lower() != "all":
                if code != culture:
                    continue
            filtered_rpg.append(feature)
        bt_deg = bt_radius_km / 111
        ht_deg = ht_radius_km / 111
        posts_bt = get_nearest_postes(lat_center, lon_center, radius_deg=bt_deg)
        posts_hta = get_nearest_ht_postes(lat_center, lon_center, radius_deg=ht_deg)
        posts_bt = [p for p in posts_bt if geom.contains(p["geometry"])]
        posts_hta = [p for p in posts_hta if geom.contains(p["geometry"])]
        map_obj = folium.Map(location=[lat_center, lon_center], zoom_start=14)
        commune_group = folium.FeatureGroup(name="Commune", show=True)
        folium.GeoJson(commune_feature["geometry"],
                       style_function=lambda x: {"color": "black", "weight": 2, "opacity": 0.8},
                       tooltip=f"Commune: {commune}").add_to(commune_group)
        map_obj.add_child(commune_group)
        rpg_group = folium.FeatureGroup(name="Parcelles RPG", show=True)
        for feature in filtered_rpg:
            tip = "<br>".join([f"{k}: {v}" for k, v in feature.get("properties", {}).items()])
            folium.GeoJson(feature["geometry"],
                           style_function=lambda x: {"color": "purple", "weight": 2, "opacity": 0.5},
                           tooltip=tip).add_to(rpg_group)
        map_obj.add_child(rpg_group)
        bt_group = folium.FeatureGroup(name="Postes BT", show=True)
        for p in posts_bt:
            coords = p["geometry"].centroid.coords[0]
            tip = "<br>".join([f"{k}: {v}" for k, v in p["properties"].items()])
            folium.Marker([coords[1], coords[0]],
                          popup=f"<b>Poste BT</b><br>Distance: {p['distance']} m<br>{tip}",
                          icon=folium.Icon(color="green")).add_to(bt_group)
        map_obj.add_child(bt_group)
        hta_group = folium.FeatureGroup(name="Postes HTA", show=True)
        for p in posts_hta:
            coords = p["geometry"].centroid.coords[0]
            tip = "<br>".join([f"{k}: {v}" for k, v in p["properties"].items()])
            folium.Marker([coords[1], coords[0]],
                          popup=f"<b>Poste HTA</b><br>Distance: {p['distance']} m<br>{tip}",
                          icon=folium.Icon(color="orange", icon="bolt")).add_to(hta_group)
        map_obj.add_child(hta_group)
        folium.LayerControl().add_to(map_obj)
        map_obj.save(os.path.join(app.root_path, "templates", "map.html"))
        info_response = {
            "commune": commune,
            "culture": culture,
            "ht_radius_km": ht_radius_km,
            "bt_radius_km": bt_radius_km,
            "rpg_count": len(filtered_rpg),
            "posts_bt_count": len(posts_bt),
            "posts_hta_count": len(posts_hta)
        }
        return render_template("commune_index.html", info=info_response)
    else:
        return render_template("commune_search.html")

if __name__ == "__main__":
    app.run(debug=True)
