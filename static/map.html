<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Carte interactive (map.html)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html, body, #map { height:100%; margin:0; padding:0; }
    .custom-popup { font-family: 'Poppins', Arial, sans-serif; font-size: 15px; min-width: 250px; max-width: 355px;}
    .custom-popup th { text-align: left; color: #28616a; font-weight: 500; min-width: 95px;}
    .custom-popup td { color: #2d2d2d; max-width:200px; word-break: break-word;}
    .popup-title { font-weight: 700; font-size: 18px; margin-bottom: 4px; letter-spacing: 0.3px; }
    .popup-link { color: #1474fa; text-decoration: underline; }
    .popup-link:hover { color: #0e4a92; }
    .leaflet-popup-content { padding: 6px 10px 4px 10px !important; }
    .summary-bar {
      position:absolute;top:8px;left:55px;z-index:1001;background:#fff5;
      padding:6px 18px;font-size:16px;font-family:Poppins,Arial,sans-serif;border-radius:8px;
      box-shadow:0 2px 10px #0002;min-width:200px;pointer-events:none;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="summary-bar" id="summaryBar" style="display:none"></div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Ic√¥nes personnalis√©es
    const iconBt = L.icon({iconUrl: "data:image/svg+xml;base64,"+btoa(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 40'><polygon points='23,3 5,27 18,27 14,37 35,14 20,14' fill='#ffd700' stroke='#c6a200' stroke-width='2'/></svg>`),iconSize:[32,32],iconAnchor:[16,32],popupAnchor:[0,-20]});
    const iconHta = L.icon({iconUrl:"data:image/svg+xml;base64,"+btoa(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'><polygon points='28,4 8,28 24,28 20,44 40,20 24,20' fill='#D12322' stroke='#b61a13' stroke-width='2'/></svg>`),iconSize:[38,38],iconAnchor:[19,38],popupAnchor:[0,-28]});
    const iconFeuille = L.icon({iconUrl:"data:image/svg+xml;base64,"+btoa(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><path d='M16 4 Q29 13 18 29 Q7 22 16 4 Z' fill='#34ad41' stroke='#258633' stroke-width='2'/></svg>`),iconSize:[28,28],iconAnchor:[14,28],popupAnchor:[0,-18]});
    const iconParking = L.icon({iconUrl:"data:image/svg+xml;base64,"+btoa(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect x="4" y="8" width="24" height="16" rx="6" fill="#2ecc71" stroke="#166838" stroke-width="2"/><text x="16" y="23" text-anchor="middle" font-size="14" fill="#fff" font-family="Arial" font-weight="bold">P</text></svg>`),iconSize:[28,28],iconAnchor:[14,28],popupAnchor:[0,-12]});
    const iconSolaire = L.icon({iconUrl:"data:image/svg+xml;base64,"+btoa(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><circle cx="16" cy="16" r="9" fill="#ffd700" stroke="#ffbe00" stroke-width="2"/><g><line x1="16" y1="2" x2="16" y2="8" stroke="#ffd700" stroke-width="2"/><line x1="16" y1="24" x2="16" y2="30" stroke="#ffd700" stroke-width="2"/><line x1="2" y1="16" x2="8" y2="16" stroke="#ffd700" stroke-width="2"/><line x1="24" y1="16" x2="30" y2="16" stroke="#ffd700" stroke-width="2"/></g></svg>`),iconSize:[26,26],iconAnchor:[13,26],popupAnchor:[0,-12]});

    // Carte Leaflet avec fond satellite par d√©faut
    var map = L.map('map').setView([46.8, 2], 6);
    var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: "OSM" });
    var sat = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", { attribution: "Esri Satellite" });
    sat.addTo(map);

    var baseMaps = { "Satellite": sat, "OSM": osm };
    L.control.layers(baseMaps).addTo(map);

    window._layers = [];

    // R√©sum√© dynamique (ex : nb objets)
    function updateSummaryBar() {
      const n = window._layers.reduce((acc, l) => acc + (l.getLayers ? l.getLayers().length : 0), 0);
      let communes = new Set();
      window._layers.forEach(l => l.eachLayer?.(lyr => {
        if(lyr.feature?.properties?.commune) communes.add(lyr.feature.properties.commune);
        if(lyr.feature?.properties?.libelleCom) communes.add(lyr.feature.properties.libelleCom);
      }));
      let bar = document.getElementById('summaryBar');
      bar.innerHTML = `<b>Objets affich√©s :</b> ${n}${communes.size>0?` &nbsp;|&nbsp; <b>Communes :</b> ${communes.size}`:""}`;
      bar.style.display = n>0 ? "" : "none";
    }

    window.clearMap = function() {
      window._layers.forEach(l => map.removeLayer(l));
      window._layers = [];
      updateSummaryBar();
    };

    // Popups riches & dynamiques
    function makePopupContent(props, typeLayer, geometry) {
      function row(label, val) { return val ? `<tr><th>${label}</th><td>${val}</td></tr>` : ""; }
      
      // Fonction pour calculer le centro√Øde d'une g√©om√©trie
      function getCentroid(geom) {
        if (!geom || !geom.coordinates) return null;
        
        let lat = 0, lon = 0, count = 0;
        
        if (geom.type === 'Point') {
          return { lat: geom.coordinates[1], lon: geom.coordinates[0] };
        } else if (geom.type === 'Polygon' && geom.coordinates.length > 0) {
          // Pour un polygone, on calcule la moyenne des coordonn√©es du premier ring
          const ring = geom.coordinates[0];
          ring.forEach(coord => {
            lon += coord[0];
            lat += coord[1];
            count++;
          });
          return count > 0 ? { lat: lat/count, lon: lon/count } : null;
        } else if (geom.type === 'MultiPolygon' && geom.coordinates.length > 0) {
          // Pour un multi-polygone, on prend le premier polygone
          const firstPolygon = geom.coordinates[0];
          if (firstPolygon.length > 0) {
            const ring = firstPolygon[0];
            ring.forEach(coord => {
              lon += coord[0];
              lat += coord[1];
              count++;
            });
            return count > 0 ? { lat: lat/count, lon: lon/count } : null;
          }
        }
        return null;
      }
      
      // Fonction pour cr√©er le lien Google Street View
      function createStreetViewLink(geom) {
        const centroid = getCentroid(geom);
        if (!centroid) return "";
        
        const streetViewUrl = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${centroid.lat},${centroid.lon}`;
        return `<a href="${streetViewUrl}" target="_blank" class="popup-link" style="color: #1474fa; text-decoration: none; padding: 4px 8px; background: #f0f8ff; border-radius: 4px; display: inline-block; margin-top: 4px;">
          üìç Voir sur Google Street View
        </a>`;
      }
      // --- Parcelles cadastrales / API cadastre / RPG
      if (typeLayer === "parcelles" || typeLayer === "api_cadastre" || typeLayer==="rpg" || typeLayer==="rpg_parcelles") {
        let html = `<div class='custom-popup'><div class='popup-title' style="color:#FF6600">Parcelle cadastrale</div><table>`;
        html+=row("Section",props.section); html+=row("Num√©ro",props.numero);
        html+=row("Surface (ha)",props.surface_ha); html+=row("Surface (m¬≤)",props.surface);
        html+=row("Adresse",props.adresse); html+=row("Commune",props.commune||props.nomcommune);
        html+=row("Propri√©taire",props.proprietaire||props.nomproprietaire);
        html+=row("Nature culture",props.culture);
        html+=`</table></div>`;
        return html;
      }
      // --- Nature & Urbanisme (API IGN)
      if (typeLayer === "api_nature" || typeLayer === "api_urbanisme") {
        return `<div class='custom-popup'><div class='popup-title' style="color:${typeLayer==="api_nature"?"#22AA22":"#0000FF"}">
          ${typeLayer==="api_nature"?"Zone Naturelle":"Zone Urbanisme"}</div>
        <table>
          ${row("Type",props.type||props.nature||props.nom)}
          ${row("Description",props.description)}
          ${row("Lien",props.url?`<a href="${props.url}" class="popup-link" target="_blank">Voir fiche</a>`:"")}
        </table></div>`;
      }
      // --- Postes HTA
      if (typeLayer === "postes_hta") {
        let html = `<div class='custom-popup'><div class='popup-title' style="color:#d12322">Poste HTA</div><table>`;
        ["Nom","Code","Puissance","Tension av","S3REnR","Taux d'aff","Capacit√©"].forEach(f=> html+=row(f,props[f]||props[f.replace(/ /g,"_")]));
        html+=`</table></div>`;
        return html;
      }
      // --- Postes BT
      if (typeLayer === "postes_bt") {
        let nom = props.NOM || props.nom || props.Nom || "Poste";
        let c = props.coords || (props.geometry && props.geometry.coordinates) || [];
        let lat, lon;
        if (Array.isArray(c) && c.length === 2) { lat=c[0]; lon=c[1]; }
        if ((!lat || !lon) && props.geometry && props.geometry.type === "Point") {
          lat = props.geometry.coordinates[1];
          lon = props.geometry.coordinates[0];
        }
        let gmap = (lat && lon) ? `https://www.google.com/maps/@${lat},${lon},18z` : null;
        let street = (lat && lon) ? `https://www.google.com/maps?q=&layer=c&cbll=${lat},${lon}` : null;
        let html = `<div class='custom-popup'><div class='popup-title' style="color:#b6a800">Poste BT</div><table>`;
        html+=row("Nom",nom); html+=row("Capacit√©",props.CAPACITE||props.capacite);
        html+=row("Tension",props.TENSION||props.tension);
        if(gmap) html+=row("Google Maps", `<a href="${gmap}" target="_blank" class="popup-link">Voir la carte</a>`);
        if(street) html+=row("Street View", `<a href="${street}" target="_blank" class="popup-link">Voir la rue</a>`);
        html+=`</table></div>`;
        return html;
      }
      // --- Friches
      if (typeLayer === "friches") {
        return `<div class='custom-popup'><div class='popup-title' style="color:brown">Friche</div>
        <table>
          ${row("Nom",props.nom)}
          ${row("Surface (ha)",props.surface_ha)}
          ${row("Type",props.type_friche)}
          ${row("Statut",props.statut)}
        </table></div>`;
      }
      // --- Parkings
      if (typeLayer === "parkings") {
        // Fonction pour formater les parcelles cadastrales
        function formatParcelleCadastrale(parcelles) {
          if (!Array.isArray(parcelles) || parcelles.length === 0) return "Aucune";
          return parcelles.map(parcelle => {
            if (parcelle && typeof parcelle === 'object' && parcelle.reference_complete) {
              return parcelle.reference_complete;
            }
            if (parcelle && typeof parcelle === 'object') {
              const commune = parcelle.commune || '';
              const prefixe = parcelle.prefixe || '';
              const section = parcelle.section || '';
              const numero = parcelle.numero || '';
              return `${commune}${prefixe}${section}${numero}`.trim();
            }
            return String(parcelle);
          }).join(', ');
        }
        
        const streetViewLink = createStreetViewLink(geometry);
        
        return `<div class='custom-popup'><div class='popup-title' style="color:darkgreen">Parking</div>
        <table>
          ${row("Nom",props.nom||props.nom_parking)}
          ${row("Surface (m¬≤)",props.surface)}
          ${row("Nombre de places",props.places)}
          ${row("Parcelles cadastrales", formatParcelleCadastrale(props.parcelles_cadastrales))}
          ${row("Nb parcelles cadastrales", props.nb_parcelles_cadastrales)}
          ${row("Distance poste BT (m)", props.min_poste_distance_m ? Math.round(props.min_poste_distance_m * 100) / 100 : '')}
        </table>
        ${streetViewLink}
        </div>`;
      }
      // --- Potentiel Solaire / Toitures
      if (typeLayer === "solaire") {
        // Fonction pour formater les parcelles cadastrales (identique aux parkings)
        function formatParcelleCadastrale(parcelles) {
          if (!Array.isArray(parcelles) || parcelles.length === 0) return "Aucune";
          return parcelles.map(parcelle => {
            if (parcelle && typeof parcelle === 'object' && parcelle.reference_complete) {
              return parcelle.reference_complete;
            }
            if (parcelle && typeof parcelle === 'object') {
              const commune = parcelle.commune || '';
              const prefixe = parcelle.prefixe || '';
              const section = parcelle.section || '';
              const numero = parcelle.numero || '';
              return `${commune}${prefixe}${section}${numero}`.trim();
            }
            return String(parcelle);
          }).join(', ');
        }
        
        const streetViewLink = createStreetViewLink(geometry);
        
        // D√©tecter s'il s'agit de toitures ou de vraies donn√©es solaires
        if (props.surface_toiture_m2 || props.search_method || props.min_distance_bt_m !== undefined) {
          // C'est une toiture enrichie
          return `<div class='custom-popup'><div class='popup-title' style="color:gold">üè† Toiture s√©lectionn√©e</div>
          <table>
            ${row("Surface toiture (m¬≤)", props.surface_toiture_m2)}
            ${row("Distance poste BT (m)", props.min_distance_bt_m)}
            ${row("Distance poste HTA (m)", props.min_distance_hta_m)}
            ${row("Commune", props.commune)}
            ${row("Code INSEE", props.insee)}
            ${row("Parcelles cadastrales", formatParcelleCadastrale(props.parcelles_cadastrales))}
            ${row("Nb parcelles cadastrales", props.nb_parcelles_cadastrales)}
            ${row("Source", props.source || "B√¢timent IGN")}
          </table>
          ${streetViewLink}
          </div>`;
        } else {
          // Vraies donn√©es de potentiel solaire
          return `<div class='custom-popup'><div class='popup-title' style="color:gold">‚òÄÔ∏è Potentiel solaire</div>
          <table>
            ${row("Nom",props.nom)}
            ${row("Surface (ha)",props.surface_ha)}
            ${row("Puissance (MWc)",props.puissance)}
            ${row("Exposition",props.exposition)}
            ${row("Inclinaison",props.inclinaison)}
          </table></div>`;
        }
      }
      // --- ZAER
      if (typeLayer === "zaer") {
        return `<div class='custom-popup'><div class='popup-title' style="color:cyan">ZAER</div>
        <table>
          ${row("Libell√©",props.libelle)}
          ${row("Surface (ha)",props.surface_ha)}
          ${row("Statut",props.statut)}
        </table></div>`;
      }
      // --- Sirene
      if (typeLayer === "sirene") {
        return `<div class='custom-popup'><div class='popup-title' style="color:darkred">√âtablissement Sirene</div>
        <table>
          ${row("Nom",props.nom)}
          ${row("Activit√©",props.activite)}
          ${row("Adresse",props.adresse)}
          ${row("SIRET",props.siret)}
          ${row("Effectif",props.effectif)}
        </table></div>`;
      }
      // --- √âleveurs
      if (typeLayer === "eleveurs") {
        const eleveurLabels = {
          "Siret": "SIRET",
          "DateCreati": "Date de cr√©ation", 
          "Denominati": "D√©nomination",
          "NomUniteLe": "Nom unit√© l√©gale",
          "NomUsageUn": "Nom d'usage",
          "Prenom1Uni": "Pr√©nom",
          "ActivitePr": "Activit√© principale",
          "NumeroVoie": "N¬∞ voie", 
          "TypeVoieEt": "Type voie",
          "LibelleVoi": "Libell√© voie",
          "CodePostal": "CP",
          "LibelleCom": "Commune",
          "CodeCommun": "Code commune",
          "X": "X (m, EPSG:2154)",
          "Y": "Y (m, EPSG:2154)",
          "Siren": "SIREN",
          "Nic": "NIC"
        };
        
        // Construction du nom complet
        let nomComplet = "";
        if (props.Prenom1Uni && props.NomUniteLe) {
          nomComplet = `${props.Prenom1Uni} ${props.NomUniteLe}`;
        } else if (props.NomUniteLe) {
          nomComplet = props.NomUniteLe;
        } else if (props.Denominati) {
          nomComplet = props.Denominati;
        } else if (props.NomUsageUn) {
          nomComplet = props.NomUsageUn;
        }
        
        // Construction de l'adresse compl√®te
        let adresseComplete = "";
        const numeroVoie = props.NumeroVoie || props["NumeroVo 1"] || "";
        const typeVoie = props.TypeVoieEt || props.TypeVoie2E || "";
        const libelleVoie = props.LibelleVoi || props["LibelleV 1"] || "";
        const codePostal = props.CodePostal || props["CodePost 1"] || "";
        const commune = props.LibelleCom || props["LibelleC 1"] || "";
        
        if (numeroVoie || typeVoie || libelleVoie) {
          adresseComplete = [numeroVoie, typeVoie, libelleVoie].filter(x => x).join(" ");
          if (codePostal || commune) {
            adresseComplete += ", " + [codePostal, commune].filter(x => x).join(" ");
          }
        } else if (codePostal || commune) {
          adresseComplete = [codePostal, commune].filter(x => x).join(" ");
        }
        
        let html = `<div class='custom-popup'><div class='popup-title' style="color:purple">üêÑ √âleveur</div><table>`;
        
        // Informations principales
        if (nomComplet) html += row("Nom", nomComplet);
        if (props.Denominati && props.Denominati !== nomComplet) html += row("D√©nomination", props.Denominati);
        if (adresseComplete) html += row("Adresse", adresseComplete);
        if (props.Siret) html += row("SIRET", props.Siret);
        if (props.ActivitePr) html += row("Activit√© principale", props.ActivitePr);
        if (props.DateCreati) html += row("Date de cr√©ation", props.DateCreati);
        
        // Liens vers les annuaires d'entreprises
        if (props.Siret) {
          const siret = props.Siret;
          const siren = props.Siren || siret.substring(0, 9);
          
          // Lien Societe.com avec format sp√©cifique
          const denominationUrl = (props.Denominati || nomComplet || "").toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
          const societeUrl = `https://www.societe.com/societe/${denominationUrl}-${siren}.html`;
          html += row("Societe.com", `<a href="${societeUrl}" target="_blank" class="popup-link">Voir la fiche entreprise</a>`);
          
          // Lien Pages Jaunes
          const denomination = encodeURIComponent(props.Denominati || nomComplet || "");
          const ville = encodeURIComponent(commune || "");
          const codePostalFormatted = encodeURIComponent(codePostal ? `(${codePostal})` : "");
          const pagesJaunesUrl = `https://www.pagesjaunes.fr/annuaire/chercherlespros?quoiqui=${denomination}&ou=${ville}+${codePostalFormatted}&univers=pagesjaunes&idOu=`;
          html += row("Pages Jaunes", `<a href="${pagesJaunesUrl}" target="_blank" class="popup-link">Consulter l'annuaire</a>`);
        }
        
        html += `</table></div>`;
        return html;
      }
      // --- Fallback g√©n√©rique
      let html = `<div class="custom-popup"><table>`;
      for(const [k,v] of Object.entries(props)) {
        if (typeof v === "string" && v.startsWith("http")) {
          html += `<tr><th>${k}</th><td><a href="${v}" class="popup-link" target="_blank">${v.replace(/^https?:\/\//,'')}</a></td></tr>`;
        } else if (typeof v === "string" || typeof v === "number") {
          html += `<tr><th>${k}</th><td>${v}</td></tr>`;
        }
      }
      html += "</table></div>";
      return html;
    }

    // D√©tection automatique du type de couche
    function detectTypeLayer(f, s) {
      if(f.properties && f.properties._layer) return f.properties._layer;
      if(s && s.color === "orange") return "postes_bt";
      if(s && s.color === "red") return "postes_hta";
      if(s && s.color === "purple") return "eleveurs";
      if(s && s.color === "#FF6600") return "api_cadastre";
      if(s && s.color === "#22AA22") return "api_nature";
      if(s && s.color === "#0000FF") return "api_urbanisme";
      if(s && s.color === "darkgreen") return "parkings";
      if(s && s.color === "gold") return "solaire";
      if(s && s.color === "cyan") return "zaer";
      if(s && s.color === "darkred") return "sirene";
      if(f.properties && (f.properties.nomUniteLe || f.properties.denomination || f.properties.NomUniteLe || f.properties.Denominati || f.properties.Siret)) return "eleveurs";
      if(f.properties && (f.properties.NOM || f.properties.nom || f.properties.Nom)) {
        let name = (f.properties.NOM || f.properties.nom || f.properties.Nom).toLowerCase();
        if (name.includes('hta')) return "postes_hta";
        if (name.includes('bt')) return "postes_bt";
      }
      return "";
    }

    // Ajout sur la carte + popups enrichies + ic√¥nes
    window.addGeoJsonToMap = function(feature, style) {
      if(!feature) return;
      var gj = L.geoJSON(feature, {
        style: style || {},
        pointToLayer: function (f, latlng) {
          let typeLayer = detectTypeLayer(f, style);
          if(typeLayer === "postes_bt") return L.marker(latlng, {icon: iconBt});
          if(typeLayer === "postes_hta") return L.marker(latlng, {icon: iconHta});
          if(typeLayer === "eleveurs") return L.marker(latlng, {icon: iconFeuille});
          if(typeLayer === "parkings") return L.marker(latlng, {icon: iconParking});
          if(typeLayer === "solaire") return L.marker(latlng, {icon: iconSolaire});
          // Default : point bleu √©l√©gant
          return L.circleMarker(latlng, { radius: 8, color: style?.color || "#3388ff", fillColor: "#8cc0ff", fillOpacity: 0.65, weight: 2 });
        },
        onEachFeature: function (feat, layer) {
          let typeLayer = detectTypeLayer(feat, style);
          layer.bindPopup(makePopupContent(feat.properties, typeLayer, feat.geometry), {maxWidth: 340});
        }
      }).addTo(map);
      window._layers.push(gj);
      updateSummaryBar();
    };

    window.setView = function(lat, lon, zoom) {
      map.setView([lat, lon], zoom || 8);
    };
    
    // √âcoute des messages de zoom depuis le rapport
    window.addEventListener('message', function(event) {
      console.log('Message re√ßu dans la carte:', event.data);
      
      // Supporter les deux formats de messages
      if (event.data && (event.data.action === 'zoomTo' || event.data.type === 'zoom')) {
        const { lat, lng, zoom, name, type } = event.data;
        
        console.log(`Zoom demand√© vers: ${name} (${type}) √† [${lat}, ${lng}] avec zoom ${zoom}`);
        
        // V√©rifier que les coordonn√©es sont valides
        if (isNaN(lat) || isNaN(lng)) {
          console.error('Coordonn√©es invalides re√ßues:', { lat, lng });
          return;
        }
        
        try {
          // Zoomer sur les coordonn√©es
          map.setView([lat, lng], zoom || 16);
          console.log('Zoom effectu√© avec succ√®s');
          
          // Optionnel : ajouter un marqueur temporaire pour indiquer la position
          const tempMarker = L.marker([lat, lng])
            .addTo(map)
            .bindPopup(`<b>${name || '√âl√©ment'}</b><br>Type: ${type || 'Point'}`)
            .openPopup();
            
          console.log('Marqueur temporaire ajout√©');
            
          // Supprimer le marqueur temporaire apr√®s 5 secondes
          setTimeout(() => {
            map.removeLayer(tempMarker);
            console.log('Marqueur temporaire supprim√©');
          }, 5000);
          
        } catch (error) {
          console.error('Erreur lors du zoom:', error);
        }
      } else {
        console.log('Message ignor√© - action non reconnue:', event.data?.action || event.data?.type);
      }
    });
    
    window._leaflet_ready = true;
  </script>
</body>
</html>
